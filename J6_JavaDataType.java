/*
Java มี 8 ชนิดข้อมูลดั้งเดิม; ถ่าน, บูลีน, ไบต์, สั้น, int, ยาว, ลอยและ double สำหรับแบบฝึกหัดนี้ เราจะทำงานกับค่าพื้นฐานที่ใช้เก็บค่าจำนวนเต็ม ( byte, short, intและlong ):
ไบต์เป็นจำนวนเต็มที่มีเครื่องหมาย 8 บิต
short เป็นจำนวนเต็มที่มีเครื่องหมาย 16 บิต
int เป็นจำนวนเต็มที่มีเครื่องหมาย 32 บิต
Long เป็น จำนวนเต็มที่มีเครื่องหมาย 64 บิต
คุณต้องพิจารณาว่าข้อมูลดั้งเดิมประเภทใดที่สามารถจัดเก็บอินพุตนั้นได้อย่างถูกต้อง

เพื่อให้คุณเริ่มต้นได้ ส่วนหนึ่งของโซลูชันมีให้ในตัวแก้ไข

ข้อมูลอ้างอิง: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html

รูปแบบการป้อนข้อมูล
บรรทัดแรก T มีจำนวนเต็มแสดงถึงจำนวนกรณีทดสอบ
แต่ละกรณีทดสอบ T ประกอบด้วยบรรทัดเดียวที่มีจำนวนเต็ม n ซึ่งสามารถใหญ่หรือเล็กได้ตามอำเภอใจ
รูปแบบเอาต์พุต
สำหรับแต่ละตัวแปรอินพุต n และดั้งเดิมที่เหมาะสม dataType คุณต้องพิจารณาว่าวัตถุดั้งเดิมที่กำหนดสามารถจัดเก็บได้หรือไม่ ถ้าใช่ พิมพ์ว่า
n can be fitted in:
* dataType
หากมีประเภทข้อมูลที่เหมาะสมมากกว่าหนึ่งประเภท ให้พิมพ์แต่ละรายการในบรรทัดของตัวเองและเรียงลำดับตามขนาด (เช่น:bype < short < int < long).
หากไม่สามารถเก็บหมายเลขไว้ในหนึ่งในสี่ดั้งเดิมข้างต้น ให้พิมพ์บรรทัด:

n can't be fitted anywhere.
อินพุตตัวอย่าง

5
-150
150000
1500000000
213333333333333333333333333333333333
-100000000000000
เอาต์พุตตัวอย่าง

-150 can be fitted in:
* short
* int
* long
150000 can be fitted in:
* int
* long
1500000000 can be fitted in:
* int
* long
213333333333333333333333333333333333 can't be fitted anywhere.
-100000000000000 can be fitted in:
* long
คำอธิบาย
-150 สามารถเก็บไว้ในshort , intหรือlong
213333333333333333333333333333333333 มีขนาดใหญ่มากและอยู่นอกช่วงค่าที่อนุญาตสำหรับชนิดข้อมูลดั้งเดิมที่กล่าวถึงในปัญหานี้
 */

import java.util.*;
import java.io.*;
public class J6_JavaDataType {
    public static void main(String []argh) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();

        for (int i = 0; i < t; i++) {
            try {
                long x = sc.nextLong();
                System.out.println(x + " can be fitted in:");
                if (x >= -128 && x <= 127) {
                    System.out.println("* byte");
                }
                if (x >= -Math.pow(2, 15) && x <= Math.pow(2, 15) - 1) {
                    System.out.println("* short");
                }
                if (x >= -Math.pow(2, 31) && x <= Math.pow(2, 31) - 1) {
                    System.out.println("* int");
                }
                if (x >= -Math.pow(2, 63) && x <= Math.pow(2, 63) - 1) {
                    System.out.println("* long");
                }
            } catch (Exception e) {
                System.out.println(sc.next() + " can't be fitted anywhere.");
            }
        }
    }
}

/*
ในส่วนที่เพิ่มเข้าไป เราใช้ลูป for เพื่อวนลูปตามจำนวนที่ระบุโดยผู้ใช้ t และในแต่ละรอบของลูป เราใช้ try-catch เพื่อตรวจสอบว่าจำนวนเต็มที่รับเข้ามา
สามารถเก็บไว้ในชนิดข้อมูลต่าง ๆ ได้หรือไม่ ในกรณีที่ตัวเลขสามารถเก็บไว้ในชนิด byte, short, int, หรือ long เราจะพิมพ์ข้อความที่บอกว่าจำนวนเต็มนั้น
สามารถเก็บไว้ในชนิดข้อมูลดังกล่าวได้ แต่ถ้าไม่สามารถเก็บไว้ในชนิดข้อมูลใด ๆ เลย เราจะพิมพ์ข้อความที่บอกว่าจำนวนนั้นไม่สามารถเก็บไว้ในชนิดข้อมูลใด ๆ
สรุปแล้ว โค้ดนี้จะรับจำนวนเต็ม t จากผู้ใช้ และตรวจสอบว่าจำนวนเต็มที่รับเข้ามาสามารถเก็บไว้ในชนิดข้อมูลต่าง ๆ ได้หรือไม่ และพิมพ์ผลลัพธ์ตามที่โจทย์กำหนด
 */